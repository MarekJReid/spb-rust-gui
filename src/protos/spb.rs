// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `spb.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct Payload {
    // message fields
    pub timestamp: u64,
    pub metrics: ::protobuf::RepeatedField<Payload_Metric>,
    pub seq: u64,
    pub uuid: ::std::string::String,
    pub body: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload {
    fn default() -> &'a Payload {
        <Payload as ::protobuf::Message>::default_instance()
    }
}

impl Payload {
    pub fn new() -> Payload {
        ::std::default::Default::default()
    }

    // uint64 timestamp = 1;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    // repeated .org.eclipse.tahu.protobuf.Payload.Metric metrics = 2;


    pub fn get_metrics(&self) -> &[Payload_Metric] {
        &self.metrics
    }
    pub fn clear_metrics(&mut self) {
        self.metrics.clear();
    }

    // Param is passed by value, moved
    pub fn set_metrics(&mut self, v: ::protobuf::RepeatedField<Payload_Metric>) {
        self.metrics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metrics(&mut self) -> &mut ::protobuf::RepeatedField<Payload_Metric> {
        &mut self.metrics
    }

    // Take field
    pub fn take_metrics(&mut self) -> ::protobuf::RepeatedField<Payload_Metric> {
        ::std::mem::replace(&mut self.metrics, ::protobuf::RepeatedField::new())
    }

    // uint64 seq = 3;


    pub fn get_seq(&self) -> u64 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u64) {
        self.seq = v;
    }

    // string uuid = 4;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }

    // bytes body = 5;


    pub fn get_body(&self) -> &[u8] {
        &self.body
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.body = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.body
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.body, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Payload {
    fn is_initialized(&self) -> bool {
        for v in &self.metrics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metrics)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seq = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(3, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.uuid);
        }
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.body);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_uint64(1, self.timestamp)?;
        }
        for v in &self.metrics {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.seq != 0 {
            os.write_uint64(3, self.seq)?;
        }
        if !self.uuid.is_empty() {
            os.write_string(4, &self.uuid)?;
        }
        if !self.body.is_empty() {
            os.write_bytes(5, &self.body)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload {
        Payload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &Payload| { &m.timestamp },
                |m: &mut Payload| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_Metric>>(
                "metrics",
                |m: &Payload| { &m.metrics },
                |m: &mut Payload| { &mut m.metrics },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seq",
                |m: &Payload| { &m.seq },
                |m: &mut Payload| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &Payload| { &m.uuid },
                |m: &mut Payload| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "body",
                |m: &Payload| { &m.body },
                |m: &mut Payload| { &mut m.body },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload>(
                "Payload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload {
        static instance: ::protobuf::rt::LazyV2<Payload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload::new)
    }
}

impl ::protobuf::Clear for Payload {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.metrics.clear();
        self.seq = 0;
        self.uuid.clear();
        self.body.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_Template {
    // message fields
    pub version: ::std::string::String,
    pub metrics: ::protobuf::RepeatedField<Payload_Metric>,
    pub parameters: ::protobuf::RepeatedField<Payload_Template_Parameter>,
    pub template_ref: ::std::string::String,
    pub is_definition: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_Template {
    fn default() -> &'a Payload_Template {
        <Payload_Template as ::protobuf::Message>::default_instance()
    }
}

impl Payload_Template {
    pub fn new() -> Payload_Template {
        ::std::default::Default::default()
    }

    // string version = 1;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // repeated .org.eclipse.tahu.protobuf.Payload.Metric metrics = 2;


    pub fn get_metrics(&self) -> &[Payload_Metric] {
        &self.metrics
    }
    pub fn clear_metrics(&mut self) {
        self.metrics.clear();
    }

    // Param is passed by value, moved
    pub fn set_metrics(&mut self, v: ::protobuf::RepeatedField<Payload_Metric>) {
        self.metrics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metrics(&mut self) -> &mut ::protobuf::RepeatedField<Payload_Metric> {
        &mut self.metrics
    }

    // Take field
    pub fn take_metrics(&mut self) -> ::protobuf::RepeatedField<Payload_Metric> {
        ::std::mem::replace(&mut self.metrics, ::protobuf::RepeatedField::new())
    }

    // repeated .org.eclipse.tahu.protobuf.Payload.Template.Parameter parameters = 3;


    pub fn get_parameters(&self) -> &[Payload_Template_Parameter] {
        &self.parameters
    }
    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::protobuf::RepeatedField<Payload_Template_Parameter>) {
        self.parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameters(&mut self) -> &mut ::protobuf::RepeatedField<Payload_Template_Parameter> {
        &mut self.parameters
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::protobuf::RepeatedField<Payload_Template_Parameter> {
        ::std::mem::replace(&mut self.parameters, ::protobuf::RepeatedField::new())
    }

    // string template_ref = 4;


    pub fn get_template_ref(&self) -> &str {
        &self.template_ref
    }
    pub fn clear_template_ref(&mut self) {
        self.template_ref.clear();
    }

    // Param is passed by value, moved
    pub fn set_template_ref(&mut self, v: ::std::string::String) {
        self.template_ref = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_ref(&mut self) -> &mut ::std::string::String {
        &mut self.template_ref
    }

    // Take field
    pub fn take_template_ref(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.template_ref, ::std::string::String::new())
    }

    // bool is_definition = 5;


    pub fn get_is_definition(&self) -> bool {
        self.is_definition
    }
    pub fn clear_is_definition(&mut self) {
        self.is_definition = false;
    }

    // Param is passed by value, moved
    pub fn set_is_definition(&mut self, v: bool) {
        self.is_definition = v;
    }
}

impl ::protobuf::Message for Payload_Template {
    fn is_initialized(&self) -> bool {
        for v in &self.metrics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parameters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metrics)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parameters)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.template_ref)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_definition = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        for value in &self.metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.parameters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.template_ref.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.template_ref);
        }
        if self.is_definition != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        for v in &self.metrics {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.parameters {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.template_ref.is_empty() {
            os.write_string(4, &self.template_ref)?;
        }
        if self.is_definition != false {
            os.write_bool(5, self.is_definition)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_Template {
        Payload_Template::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &Payload_Template| { &m.version },
                |m: &mut Payload_Template| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_Metric>>(
                "metrics",
                |m: &Payload_Template| { &m.metrics },
                |m: &mut Payload_Template| { &mut m.metrics },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_Template_Parameter>>(
                "parameters",
                |m: &Payload_Template| { &m.parameters },
                |m: &mut Payload_Template| { &mut m.parameters },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "template_ref",
                |m: &Payload_Template| { &m.template_ref },
                |m: &mut Payload_Template| { &mut m.template_ref },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_definition",
                |m: &Payload_Template| { &m.is_definition },
                |m: &mut Payload_Template| { &mut m.is_definition },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_Template>(
                "Payload.Template",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_Template {
        static instance: ::protobuf::rt::LazyV2<Payload_Template> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_Template::new)
    }
}

impl ::protobuf::Clear for Payload_Template {
    fn clear(&mut self) {
        self.version.clear();
        self.metrics.clear();
        self.parameters.clear();
        self.template_ref.clear();
        self.is_definition = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_Template {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_Template {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_Template_Parameter {
    // message fields
    pub name: ::std::string::String,
    pub field_type: u32,
    // message oneof groups
    pub value: ::std::option::Option<Payload_Template_Parameter_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_Template_Parameter {
    fn default() -> &'a Payload_Template_Parameter {
        <Payload_Template_Parameter as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Payload_Template_Parameter_oneof_value {
    int_value(u32),
    long_value(u64),
    float_value(f32),
    double_value(f64),
    boolean_value(bool),
    string_value(::std::string::String),
}

impl Payload_Template_Parameter {
    pub fn new() -> Payload_Template_Parameter {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint32 type = 2;


    pub fn get_field_type(&self) -> u32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = v;
    }

    // uint32 int_value = 3;


    pub fn get_int_value(&self) -> u32 {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::int_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::int_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::int_value(v))
    }

    // uint64 long_value = 4;


    pub fn get_long_value(&self) -> u64 {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::long_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_long_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_long_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::long_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_long_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::long_value(v))
    }

    // float float_value = 5;


    pub fn get_float_value(&self) -> f32 {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::float_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_float_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::float_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::float_value(v))
    }

    // double double_value = 6;


    pub fn get_double_value(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::double_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_double_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::double_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::double_value(v))
    }

    // bool boolean_value = 7;


    pub fn get_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::boolean_value(v)) => v,
            _ => false,
        }
    }
    pub fn clear_boolean_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::boolean_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boolean_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::boolean_value(v))
    }

    // string string_value = 8;


    pub fn get_string_value(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_string_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        if self.has_string_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for Payload_Template_Parameter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::int_value(is.read_uint32()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::long_value(is.read_uint64()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::float_value(is.read_float()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::double_value(is.read_double()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::boolean_value(is.read_bool()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(2, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_Template_Parameter_oneof_value::int_value(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_Template_Parameter_oneof_value::long_value(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_Template_Parameter_oneof_value::float_value(v) => {
                    my_size += 5;
                },
                &Payload_Template_Parameter_oneof_value::double_value(v) => {
                    my_size += 9;
                },
                &Payload_Template_Parameter_oneof_value::boolean_value(v) => {
                    my_size += 2;
                },
                &Payload_Template_Parameter_oneof_value::string_value(ref v) => {
                    my_size += ::protobuf::rt::string_size(8, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.field_type != 0 {
            os.write_uint32(2, self.field_type)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_Template_Parameter_oneof_value::int_value(v) => {
                    os.write_uint32(3, v)?;
                },
                &Payload_Template_Parameter_oneof_value::long_value(v) => {
                    os.write_uint64(4, v)?;
                },
                &Payload_Template_Parameter_oneof_value::float_value(v) => {
                    os.write_float(5, v)?;
                },
                &Payload_Template_Parameter_oneof_value::double_value(v) => {
                    os.write_double(6, v)?;
                },
                &Payload_Template_Parameter_oneof_value::boolean_value(v) => {
                    os.write_bool(7, v)?;
                },
                &Payload_Template_Parameter_oneof_value::string_value(ref v) => {
                    os.write_string(8, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_Template_Parameter {
        Payload_Template_Parameter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Payload_Template_Parameter| { &m.name },
                |m: &mut Payload_Template_Parameter| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "type",
                |m: &Payload_Template_Parameter| { &m.field_type },
                |m: &mut Payload_Template_Parameter| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "int_value",
                Payload_Template_Parameter::has_int_value,
                Payload_Template_Parameter::get_int_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "long_value",
                Payload_Template_Parameter::has_long_value,
                Payload_Template_Parameter::get_long_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor::<_>(
                "float_value",
                Payload_Template_Parameter::has_float_value,
                Payload_Template_Parameter::get_float_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                "double_value",
                Payload_Template_Parameter::has_double_value,
                Payload_Template_Parameter::get_double_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "boolean_value",
                Payload_Template_Parameter::has_boolean_value,
                Payload_Template_Parameter::get_boolean_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "string_value",
                Payload_Template_Parameter::has_string_value,
                Payload_Template_Parameter::get_string_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_Template_Parameter>(
                "Payload.Template.Parameter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_Template_Parameter {
        static instance: ::protobuf::rt::LazyV2<Payload_Template_Parameter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_Template_Parameter::new)
    }
}

impl ::protobuf::Clear for Payload_Template_Parameter {
    fn clear(&mut self) {
        self.name.clear();
        self.field_type = 0;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_Template_Parameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_Template_Parameter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_DataSet {
    // message fields
    pub num_of_columns: u64,
    pub columns: ::protobuf::RepeatedField<::std::string::String>,
    pub types: ::std::vec::Vec<u32>,
    pub rows: ::protobuf::RepeatedField<Payload_DataSet_Row>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_DataSet {
    fn default() -> &'a Payload_DataSet {
        <Payload_DataSet as ::protobuf::Message>::default_instance()
    }
}

impl Payload_DataSet {
    pub fn new() -> Payload_DataSet {
        ::std::default::Default::default()
    }

    // uint64 num_of_columns = 1;


    pub fn get_num_of_columns(&self) -> u64 {
        self.num_of_columns
    }
    pub fn clear_num_of_columns(&mut self) {
        self.num_of_columns = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_of_columns(&mut self, v: u64) {
        self.num_of_columns = v;
    }

    // repeated string columns = 2;


    pub fn get_columns(&self) -> &[::std::string::String] {
        &self.columns
    }
    pub fn clear_columns(&mut self) {
        self.columns.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.columns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.columns
    }

    // Take field
    pub fn take_columns(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.columns, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 types = 3;


    pub fn get_types(&self) -> &[u32] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::std::vec::Vec<u32>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.types, ::std::vec::Vec::new())
    }

    // repeated .org.eclipse.tahu.protobuf.Payload.DataSet.Row rows = 4;


    pub fn get_rows(&self) -> &[Payload_DataSet_Row] {
        &self.rows
    }
    pub fn clear_rows(&mut self) {
        self.rows.clear();
    }

    // Param is passed by value, moved
    pub fn set_rows(&mut self, v: ::protobuf::RepeatedField<Payload_DataSet_Row>) {
        self.rows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rows(&mut self) -> &mut ::protobuf::RepeatedField<Payload_DataSet_Row> {
        &mut self.rows
    }

    // Take field
    pub fn take_rows(&mut self) -> ::protobuf::RepeatedField<Payload_DataSet_Row> {
        ::std::mem::replace(&mut self.rows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Payload_DataSet {
    fn is_initialized(&self) -> bool {
        for v in &self.rows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_of_columns = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.columns)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.types)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.num_of_columns != 0 {
            my_size += ::protobuf::rt::value_size(1, self.num_of_columns, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.columns {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.types {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.rows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.num_of_columns != 0 {
            os.write_uint64(1, self.num_of_columns)?;
        }
        for v in &self.columns {
            os.write_string(2, &v)?;
        };
        for v in &self.types {
            os.write_uint32(3, *v)?;
        };
        for v in &self.rows {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_DataSet {
        Payload_DataSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_of_columns",
                |m: &Payload_DataSet| { &m.num_of_columns },
                |m: &mut Payload_DataSet| { &mut m.num_of_columns },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "columns",
                |m: &Payload_DataSet| { &m.columns },
                |m: &mut Payload_DataSet| { &mut m.columns },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "types",
                |m: &Payload_DataSet| { &m.types },
                |m: &mut Payload_DataSet| { &mut m.types },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_DataSet_Row>>(
                "rows",
                |m: &Payload_DataSet| { &m.rows },
                |m: &mut Payload_DataSet| { &mut m.rows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_DataSet>(
                "Payload.DataSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_DataSet {
        static instance: ::protobuf::rt::LazyV2<Payload_DataSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_DataSet::new)
    }
}

impl ::protobuf::Clear for Payload_DataSet {
    fn clear(&mut self) {
        self.num_of_columns = 0;
        self.columns.clear();
        self.types.clear();
        self.rows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_DataSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_DataSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_DataSet_DataSetValue {
    // message oneof groups
    pub value: ::std::option::Option<Payload_DataSet_DataSetValue_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_DataSet_DataSetValue {
    fn default() -> &'a Payload_DataSet_DataSetValue {
        <Payload_DataSet_DataSetValue as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Payload_DataSet_DataSetValue_oneof_value {
    int_value(u32),
    long_value(u64),
    float_value(f32),
    double_value(f64),
    boolean_value(bool),
    string_value(::std::string::String),
}

impl Payload_DataSet_DataSetValue {
    pub fn new() -> Payload_DataSet_DataSetValue {
        ::std::default::Default::default()
    }

    // uint32 int_value = 1;


    pub fn get_int_value(&self) -> u32 {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::int_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::int_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::int_value(v))
    }

    // uint64 long_value = 2;


    pub fn get_long_value(&self) -> u64 {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::long_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_long_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_long_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::long_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_long_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::long_value(v))
    }

    // float float_value = 3;


    pub fn get_float_value(&self) -> f32 {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::float_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_float_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::float_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::float_value(v))
    }

    // double double_value = 4;


    pub fn get_double_value(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::double_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_double_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::double_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::double_value(v))
    }

    // bool boolean_value = 5;


    pub fn get_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::boolean_value(v)) => v,
            _ => false,
        }
    }
    pub fn clear_boolean_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::boolean_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boolean_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::boolean_value(v))
    }

    // string string_value = 6;


    pub fn get_string_value(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_string_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        if self.has_string_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for Payload_DataSet_DataSetValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::int_value(is.read_uint32()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::long_value(is.read_uint64()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::float_value(is.read_float()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::double_value(is.read_double()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::boolean_value(is.read_bool()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_DataSet_DataSetValue_oneof_value::int_value(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_DataSet_DataSetValue_oneof_value::long_value(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_DataSet_DataSetValue_oneof_value::float_value(v) => {
                    my_size += 5;
                },
                &Payload_DataSet_DataSetValue_oneof_value::double_value(v) => {
                    my_size += 9;
                },
                &Payload_DataSet_DataSetValue_oneof_value::boolean_value(v) => {
                    my_size += 2;
                },
                &Payload_DataSet_DataSetValue_oneof_value::string_value(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_DataSet_DataSetValue_oneof_value::int_value(v) => {
                    os.write_uint32(1, v)?;
                },
                &Payload_DataSet_DataSetValue_oneof_value::long_value(v) => {
                    os.write_uint64(2, v)?;
                },
                &Payload_DataSet_DataSetValue_oneof_value::float_value(v) => {
                    os.write_float(3, v)?;
                },
                &Payload_DataSet_DataSetValue_oneof_value::double_value(v) => {
                    os.write_double(4, v)?;
                },
                &Payload_DataSet_DataSetValue_oneof_value::boolean_value(v) => {
                    os.write_bool(5, v)?;
                },
                &Payload_DataSet_DataSetValue_oneof_value::string_value(ref v) => {
                    os.write_string(6, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_DataSet_DataSetValue {
        Payload_DataSet_DataSetValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "int_value",
                Payload_DataSet_DataSetValue::has_int_value,
                Payload_DataSet_DataSetValue::get_int_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "long_value",
                Payload_DataSet_DataSetValue::has_long_value,
                Payload_DataSet_DataSetValue::get_long_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor::<_>(
                "float_value",
                Payload_DataSet_DataSetValue::has_float_value,
                Payload_DataSet_DataSetValue::get_float_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                "double_value",
                Payload_DataSet_DataSetValue::has_double_value,
                Payload_DataSet_DataSetValue::get_double_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "boolean_value",
                Payload_DataSet_DataSetValue::has_boolean_value,
                Payload_DataSet_DataSetValue::get_boolean_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "string_value",
                Payload_DataSet_DataSetValue::has_string_value,
                Payload_DataSet_DataSetValue::get_string_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_DataSet_DataSetValue>(
                "Payload.DataSet.DataSetValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_DataSet_DataSetValue {
        static instance: ::protobuf::rt::LazyV2<Payload_DataSet_DataSetValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_DataSet_DataSetValue::new)
    }
}

impl ::protobuf::Clear for Payload_DataSet_DataSetValue {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_DataSet_DataSetValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_DataSet_DataSetValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_DataSet_Row {
    // message fields
    pub elements: ::protobuf::RepeatedField<Payload_DataSet_DataSetValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_DataSet_Row {
    fn default() -> &'a Payload_DataSet_Row {
        <Payload_DataSet_Row as ::protobuf::Message>::default_instance()
    }
}

impl Payload_DataSet_Row {
    pub fn new() -> Payload_DataSet_Row {
        ::std::default::Default::default()
    }

    // repeated .org.eclipse.tahu.protobuf.Payload.DataSet.DataSetValue elements = 1;


    pub fn get_elements(&self) -> &[Payload_DataSet_DataSetValue] {
        &self.elements
    }
    pub fn clear_elements(&mut self) {
        self.elements.clear();
    }

    // Param is passed by value, moved
    pub fn set_elements(&mut self, v: ::protobuf::RepeatedField<Payload_DataSet_DataSetValue>) {
        self.elements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_elements(&mut self) -> &mut ::protobuf::RepeatedField<Payload_DataSet_DataSetValue> {
        &mut self.elements
    }

    // Take field
    pub fn take_elements(&mut self) -> ::protobuf::RepeatedField<Payload_DataSet_DataSetValue> {
        ::std::mem::replace(&mut self.elements, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Payload_DataSet_Row {
    fn is_initialized(&self) -> bool {
        for v in &self.elements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.elements)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.elements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.elements {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_DataSet_Row {
        Payload_DataSet_Row::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_DataSet_DataSetValue>>(
                "elements",
                |m: &Payload_DataSet_Row| { &m.elements },
                |m: &mut Payload_DataSet_Row| { &mut m.elements },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_DataSet_Row>(
                "Payload.DataSet.Row",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_DataSet_Row {
        static instance: ::protobuf::rt::LazyV2<Payload_DataSet_Row> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_DataSet_Row::new)
    }
}

impl ::protobuf::Clear for Payload_DataSet_Row {
    fn clear(&mut self) {
        self.elements.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_DataSet_Row {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_DataSet_Row {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_PropertyValue {
    // message fields
    pub field_type: u32,
    pub is_null: bool,
    // message oneof groups
    pub value: ::std::option::Option<Payload_PropertyValue_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_PropertyValue {
    fn default() -> &'a Payload_PropertyValue {
        <Payload_PropertyValue as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Payload_PropertyValue_oneof_value {
    int_value(u32),
    long_value(u64),
    float_value(f32),
    double_value(f64),
    boolean_value(bool),
    string_value(::std::string::String),
    propertyset_value(Payload_PropertySet),
    propertysets_value(Payload_PropertySetList),
}

impl Payload_PropertyValue {
    pub fn new() -> Payload_PropertyValue {
        ::std::default::Default::default()
    }

    // uint32 type = 1;


    pub fn get_field_type(&self) -> u32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = v;
    }

    // bool is_null = 2;


    pub fn get_is_null(&self) -> bool {
        self.is_null
    }
    pub fn clear_is_null(&mut self) {
        self.is_null = false;
    }

    // Param is passed by value, moved
    pub fn set_is_null(&mut self, v: bool) {
        self.is_null = v;
    }

    // uint32 int_value = 3;


    pub fn get_int_value(&self) -> u32 {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::int_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::int_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::int_value(v))
    }

    // uint64 long_value = 4;


    pub fn get_long_value(&self) -> u64 {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::long_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_long_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_long_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::long_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_long_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::long_value(v))
    }

    // float float_value = 5;


    pub fn get_float_value(&self) -> f32 {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::float_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_float_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::float_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::float_value(v))
    }

    // double double_value = 6;


    pub fn get_double_value(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::double_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_double_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::double_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::double_value(v))
    }

    // bool boolean_value = 7;


    pub fn get_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::boolean_value(v)) => v,
            _ => false,
        }
    }
    pub fn clear_boolean_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::boolean_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boolean_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::boolean_value(v))
    }

    // string string_value = 8;


    pub fn get_string_value(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_string_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        if self.has_string_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .org.eclipse.tahu.protobuf.Payload.PropertySet propertyset_value = 9;


    pub fn get_propertyset_value(&self) -> &Payload_PropertySet {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(ref v)) => v,
            _ => <Payload_PropertySet as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_propertyset_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_propertyset_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_propertyset_value(&mut self, v: Payload_PropertySet) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_propertyset_value(&mut self) -> &mut Payload_PropertySet {
        if let ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(Payload_PropertySet::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_propertyset_value(&mut self) -> Payload_PropertySet {
        if self.has_propertyset_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(v)) => v,
                _ => panic!(),
            }
        } else {
            Payload_PropertySet::new()
        }
    }

    // .org.eclipse.tahu.protobuf.Payload.PropertySetList propertysets_value = 10;


    pub fn get_propertysets_value(&self) -> &Payload_PropertySetList {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(ref v)) => v,
            _ => <Payload_PropertySetList as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_propertysets_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_propertysets_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_propertysets_value(&mut self, v: Payload_PropertySetList) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_propertysets_value(&mut self) -> &mut Payload_PropertySetList {
        if let ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(Payload_PropertySetList::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_propertysets_value(&mut self) -> Payload_PropertySetList {
        if self.has_propertysets_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(v)) => v,
                _ => panic!(),
            }
        } else {
            Payload_PropertySetList::new()
        }
    }
}

impl ::protobuf::Message for Payload_PropertyValue {
    fn is_initialized(&self) -> bool {
        if let Some(Payload_PropertyValue_oneof_value::propertyset_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Payload_PropertyValue_oneof_value::propertysets_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_null = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::int_value(is.read_uint32()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::long_value(is.read_uint64()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::float_value(is.read_float()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::double_value(is.read_double()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::boolean_value(is.read_bool()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(is.read_string()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_null != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_PropertyValue_oneof_value::int_value(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_PropertyValue_oneof_value::long_value(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_PropertyValue_oneof_value::float_value(v) => {
                    my_size += 5;
                },
                &Payload_PropertyValue_oneof_value::double_value(v) => {
                    my_size += 9;
                },
                &Payload_PropertyValue_oneof_value::boolean_value(v) => {
                    my_size += 2;
                },
                &Payload_PropertyValue_oneof_value::string_value(ref v) => {
                    my_size += ::protobuf::rt::string_size(8, &v);
                },
                &Payload_PropertyValue_oneof_value::propertyset_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Payload_PropertyValue_oneof_value::propertysets_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != 0 {
            os.write_uint32(1, self.field_type)?;
        }
        if self.is_null != false {
            os.write_bool(2, self.is_null)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_PropertyValue_oneof_value::int_value(v) => {
                    os.write_uint32(3, v)?;
                },
                &Payload_PropertyValue_oneof_value::long_value(v) => {
                    os.write_uint64(4, v)?;
                },
                &Payload_PropertyValue_oneof_value::float_value(v) => {
                    os.write_float(5, v)?;
                },
                &Payload_PropertyValue_oneof_value::double_value(v) => {
                    os.write_double(6, v)?;
                },
                &Payload_PropertyValue_oneof_value::boolean_value(v) => {
                    os.write_bool(7, v)?;
                },
                &Payload_PropertyValue_oneof_value::string_value(ref v) => {
                    os.write_string(8, v)?;
                },
                &Payload_PropertyValue_oneof_value::propertyset_value(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Payload_PropertyValue_oneof_value::propertysets_value(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_PropertyValue {
        Payload_PropertyValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "type",
                |m: &Payload_PropertyValue| { &m.field_type },
                |m: &mut Payload_PropertyValue| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_null",
                |m: &Payload_PropertyValue| { &m.is_null },
                |m: &mut Payload_PropertyValue| { &mut m.is_null },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "int_value",
                Payload_PropertyValue::has_int_value,
                Payload_PropertyValue::get_int_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "long_value",
                Payload_PropertyValue::has_long_value,
                Payload_PropertyValue::get_long_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor::<_>(
                "float_value",
                Payload_PropertyValue::has_float_value,
                Payload_PropertyValue::get_float_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                "double_value",
                Payload_PropertyValue::has_double_value,
                Payload_PropertyValue::get_double_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "boolean_value",
                Payload_PropertyValue::has_boolean_value,
                Payload_PropertyValue::get_boolean_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "string_value",
                Payload_PropertyValue::has_string_value,
                Payload_PropertyValue::get_string_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Payload_PropertySet>(
                "propertyset_value",
                Payload_PropertyValue::has_propertyset_value,
                Payload_PropertyValue::get_propertyset_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Payload_PropertySetList>(
                "propertysets_value",
                Payload_PropertyValue::has_propertysets_value,
                Payload_PropertyValue::get_propertysets_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_PropertyValue>(
                "Payload.PropertyValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_PropertyValue {
        static instance: ::protobuf::rt::LazyV2<Payload_PropertyValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_PropertyValue::new)
    }
}

impl ::protobuf::Clear for Payload_PropertyValue {
    fn clear(&mut self) {
        self.field_type = 0;
        self.is_null = false;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_PropertyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_PropertyValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_PropertySet {
    // message fields
    pub keys: ::protobuf::RepeatedField<::std::string::String>,
    pub values: ::protobuf::RepeatedField<Payload_PropertyValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_PropertySet {
    fn default() -> &'a Payload_PropertySet {
        <Payload_PropertySet as ::protobuf::Message>::default_instance()
    }
}

impl Payload_PropertySet {
    pub fn new() -> Payload_PropertySet {
        ::std::default::Default::default()
    }

    // repeated string keys = 1;


    pub fn get_keys(&self) -> &[::std::string::String] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    // repeated .org.eclipse.tahu.protobuf.Payload.PropertyValue values = 2;


    pub fn get_values(&self) -> &[Payload_PropertyValue] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<Payload_PropertyValue>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<Payload_PropertyValue> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<Payload_PropertyValue> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Payload_PropertySet {
    fn is_initialized(&self) -> bool {
        for v in &self.values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.keys)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.keys {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.keys {
            os.write_string(1, &v)?;
        };
        for v in &self.values {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_PropertySet {
        Payload_PropertySet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "keys",
                |m: &Payload_PropertySet| { &m.keys },
                |m: &mut Payload_PropertySet| { &mut m.keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_PropertyValue>>(
                "values",
                |m: &Payload_PropertySet| { &m.values },
                |m: &mut Payload_PropertySet| { &mut m.values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_PropertySet>(
                "Payload.PropertySet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_PropertySet {
        static instance: ::protobuf::rt::LazyV2<Payload_PropertySet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_PropertySet::new)
    }
}

impl ::protobuf::Clear for Payload_PropertySet {
    fn clear(&mut self) {
        self.keys.clear();
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_PropertySet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_PropertySet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_PropertySetList {
    // message fields
    pub propertyset: ::protobuf::RepeatedField<Payload_PropertySet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_PropertySetList {
    fn default() -> &'a Payload_PropertySetList {
        <Payload_PropertySetList as ::protobuf::Message>::default_instance()
    }
}

impl Payload_PropertySetList {
    pub fn new() -> Payload_PropertySetList {
        ::std::default::Default::default()
    }

    // repeated .org.eclipse.tahu.protobuf.Payload.PropertySet propertyset = 1;


    pub fn get_propertyset(&self) -> &[Payload_PropertySet] {
        &self.propertyset
    }
    pub fn clear_propertyset(&mut self) {
        self.propertyset.clear();
    }

    // Param is passed by value, moved
    pub fn set_propertyset(&mut self, v: ::protobuf::RepeatedField<Payload_PropertySet>) {
        self.propertyset = v;
    }

    // Mutable pointer to the field.
    pub fn mut_propertyset(&mut self) -> &mut ::protobuf::RepeatedField<Payload_PropertySet> {
        &mut self.propertyset
    }

    // Take field
    pub fn take_propertyset(&mut self) -> ::protobuf::RepeatedField<Payload_PropertySet> {
        ::std::mem::replace(&mut self.propertyset, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Payload_PropertySetList {
    fn is_initialized(&self) -> bool {
        for v in &self.propertyset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.propertyset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.propertyset {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.propertyset {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_PropertySetList {
        Payload_PropertySetList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_PropertySet>>(
                "propertyset",
                |m: &Payload_PropertySetList| { &m.propertyset },
                |m: &mut Payload_PropertySetList| { &mut m.propertyset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_PropertySetList>(
                "Payload.PropertySetList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_PropertySetList {
        static instance: ::protobuf::rt::LazyV2<Payload_PropertySetList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_PropertySetList::new)
    }
}

impl ::protobuf::Clear for Payload_PropertySetList {
    fn clear(&mut self) {
        self.propertyset.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_PropertySetList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_PropertySetList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_MetaData {
    // message fields
    pub is_multi_part: bool,
    pub content_type: ::std::string::String,
    pub size: u64,
    pub seq: u64,
    pub file_name: ::std::string::String,
    pub file_type: ::std::string::String,
    pub md5: ::std::string::String,
    pub description: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_MetaData {
    fn default() -> &'a Payload_MetaData {
        <Payload_MetaData as ::protobuf::Message>::default_instance()
    }
}

impl Payload_MetaData {
    pub fn new() -> Payload_MetaData {
        ::std::default::Default::default()
    }

    // bool is_multi_part = 1;


    pub fn get_is_multi_part(&self) -> bool {
        self.is_multi_part
    }
    pub fn clear_is_multi_part(&mut self) {
        self.is_multi_part = false;
    }

    // Param is passed by value, moved
    pub fn set_is_multi_part(&mut self, v: bool) {
        self.is_multi_part = v;
    }

    // string content_type = 2;


    pub fn get_content_type(&self) -> &str {
        &self.content_type
    }
    pub fn clear_content_type(&mut self) {
        self.content_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: ::std::string::String) {
        self.content_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content_type(&mut self) -> &mut ::std::string::String {
        &mut self.content_type
    }

    // Take field
    pub fn take_content_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content_type, ::std::string::String::new())
    }

    // uint64 size = 3;


    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }

    // uint64 seq = 4;


    pub fn get_seq(&self) -> u64 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u64) {
        self.seq = v;
    }

    // string file_name = 5;


    pub fn get_file_name(&self) -> &str {
        &self.file_name
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        &mut self.file_name
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_name, ::std::string::String::new())
    }

    // string file_type = 6;


    pub fn get_file_type(&self) -> &str {
        &self.file_type
    }
    pub fn clear_file_type(&mut self) {
        self.file_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_type(&mut self, v: ::std::string::String) {
        self.file_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_type(&mut self) -> &mut ::std::string::String {
        &mut self.file_type
    }

    // Take field
    pub fn take_file_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_type, ::std::string::String::new())
    }

    // string md5 = 7;


    pub fn get_md5(&self) -> &str {
        &self.md5
    }
    pub fn clear_md5(&mut self) {
        self.md5.clear();
    }

    // Param is passed by value, moved
    pub fn set_md5(&mut self, v: ::std::string::String) {
        self.md5 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_md5(&mut self) -> &mut ::std::string::String {
        &mut self.md5
    }

    // Take field
    pub fn take_md5(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.md5, ::std::string::String::new())
    }

    // string description = 8;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Payload_MetaData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_multi_part = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seq = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_type)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.md5)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_multi_part != false {
            my_size += 2;
        }
        if !self.content_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.content_type);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(4, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.file_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.file_name);
        }
        if !self.file_type.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.file_type);
        }
        if !self.md5.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.md5);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_multi_part != false {
            os.write_bool(1, self.is_multi_part)?;
        }
        if !self.content_type.is_empty() {
            os.write_string(2, &self.content_type)?;
        }
        if self.size != 0 {
            os.write_uint64(3, self.size)?;
        }
        if self.seq != 0 {
            os.write_uint64(4, self.seq)?;
        }
        if !self.file_name.is_empty() {
            os.write_string(5, &self.file_name)?;
        }
        if !self.file_type.is_empty() {
            os.write_string(6, &self.file_type)?;
        }
        if !self.md5.is_empty() {
            os.write_string(7, &self.md5)?;
        }
        if !self.description.is_empty() {
            os.write_string(8, &self.description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_MetaData {
        Payload_MetaData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_multi_part",
                |m: &Payload_MetaData| { &m.is_multi_part },
                |m: &mut Payload_MetaData| { &mut m.is_multi_part },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "content_type",
                |m: &Payload_MetaData| { &m.content_type },
                |m: &mut Payload_MetaData| { &mut m.content_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "size",
                |m: &Payload_MetaData| { &m.size },
                |m: &mut Payload_MetaData| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seq",
                |m: &Payload_MetaData| { &m.seq },
                |m: &mut Payload_MetaData| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_name",
                |m: &Payload_MetaData| { &m.file_name },
                |m: &mut Payload_MetaData| { &mut m.file_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_type",
                |m: &Payload_MetaData| { &m.file_type },
                |m: &mut Payload_MetaData| { &mut m.file_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "md5",
                |m: &Payload_MetaData| { &m.md5 },
                |m: &mut Payload_MetaData| { &mut m.md5 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Payload_MetaData| { &m.description },
                |m: &mut Payload_MetaData| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_MetaData>(
                "Payload.MetaData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_MetaData {
        static instance: ::protobuf::rt::LazyV2<Payload_MetaData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_MetaData::new)
    }
}

impl ::protobuf::Clear for Payload_MetaData {
    fn clear(&mut self) {
        self.is_multi_part = false;
        self.content_type.clear();
        self.size = 0;
        self.seq = 0;
        self.file_name.clear();
        self.file_type.clear();
        self.md5.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_MetaData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_MetaData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_Metric {
    // message fields
    pub name: ::std::string::String,
    pub alias: u64,
    pub timestamp: u64,
    pub datatype: u32,
    pub is_historical: bool,
    pub is_transient: bool,
    pub is_null: bool,
    pub metadata: ::protobuf::SingularPtrField<Payload_MetaData>,
    pub properties: ::protobuf::SingularPtrField<Payload_PropertySet>,
    // message oneof groups
    pub value: ::std::option::Option<Payload_Metric_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_Metric {
    fn default() -> &'a Payload_Metric {
        <Payload_Metric as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Payload_Metric_oneof_value {
    int_value(u32),
    long_value(u64),
    float_value(f32),
    double_value(f64),
    boolean_value(bool),
    string_value(::std::string::String),
    bytes_value(::std::vec::Vec<u8>),
    dataset_value(Payload_DataSet),
    template_value(Payload_Template),
}

impl Payload_Metric {
    pub fn new() -> Payload_Metric {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 alias = 2;


    pub fn get_alias(&self) -> u64 {
        self.alias
    }
    pub fn clear_alias(&mut self) {
        self.alias = 0;
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: u64) {
        self.alias = v;
    }

    // uint64 timestamp = 3;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    // uint32 datatype = 4;


    pub fn get_datatype(&self) -> u32 {
        self.datatype
    }
    pub fn clear_datatype(&mut self) {
        self.datatype = 0;
    }

    // Param is passed by value, moved
    pub fn set_datatype(&mut self, v: u32) {
        self.datatype = v;
    }

    // bool is_historical = 5;


    pub fn get_is_historical(&self) -> bool {
        self.is_historical
    }
    pub fn clear_is_historical(&mut self) {
        self.is_historical = false;
    }

    // Param is passed by value, moved
    pub fn set_is_historical(&mut self, v: bool) {
        self.is_historical = v;
    }

    // bool is_transient = 6;


    pub fn get_is_transient(&self) -> bool {
        self.is_transient
    }
    pub fn clear_is_transient(&mut self) {
        self.is_transient = false;
    }

    // Param is passed by value, moved
    pub fn set_is_transient(&mut self, v: bool) {
        self.is_transient = v;
    }

    // bool is_null = 7;


    pub fn get_is_null(&self) -> bool {
        self.is_null
    }
    pub fn clear_is_null(&mut self) {
        self.is_null = false;
    }

    // Param is passed by value, moved
    pub fn set_is_null(&mut self, v: bool) {
        self.is_null = v;
    }

    // .org.eclipse.tahu.protobuf.Payload.MetaData metadata = 8;


    pub fn get_metadata(&self) -> &Payload_MetaData {
        self.metadata.as_ref().unwrap_or_else(|| <Payload_MetaData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: Payload_MetaData) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut Payload_MetaData {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> Payload_MetaData {
        self.metadata.take().unwrap_or_else(|| Payload_MetaData::new())
    }

    // .org.eclipse.tahu.protobuf.Payload.PropertySet properties = 9;


    pub fn get_properties(&self) -> &Payload_PropertySet {
        self.properties.as_ref().unwrap_or_else(|| <Payload_PropertySet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    pub fn has_properties(&self) -> bool {
        self.properties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: Payload_PropertySet) {
        self.properties = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_properties(&mut self) -> &mut Payload_PropertySet {
        if self.properties.is_none() {
            self.properties.set_default();
        }
        self.properties.as_mut().unwrap()
    }

    // Take field
    pub fn take_properties(&mut self) -> Payload_PropertySet {
        self.properties.take().unwrap_or_else(|| Payload_PropertySet::new())
    }

    // uint32 int_value = 10;


    pub fn get_int_value(&self) -> u32 {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::int_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::int_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::int_value(v))
    }

    // uint64 long_value = 11;


    pub fn get_long_value(&self) -> u64 {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::long_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_long_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_long_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::long_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_long_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::long_value(v))
    }

    // float float_value = 12;


    pub fn get_float_value(&self) -> f32 {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::float_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_float_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::float_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::float_value(v))
    }

    // double double_value = 13;


    pub fn get_double_value(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::double_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_double_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::double_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::double_value(v))
    }

    // bool boolean_value = 14;


    pub fn get_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::boolean_value(v)) => v,
            _ => false,
        }
    }
    pub fn clear_boolean_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::boolean_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boolean_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::boolean_value(v))
    }

    // string string_value = 15;


    pub fn get_string_value(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_string_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        if self.has_string_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bytes bytes_value = 16;


    pub fn get_bytes_value(&self) -> &[u8] {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_bytes_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_bytes_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bytes_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bytes_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(::std::vec::Vec::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bytes_value(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_bytes_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // .org.eclipse.tahu.protobuf.Payload.DataSet dataset_value = 17;


    pub fn get_dataset_value(&self) -> &Payload_DataSet {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(ref v)) => v,
            _ => <Payload_DataSet as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_dataset_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_dataset_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dataset_value(&mut self, v: Payload_DataSet) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dataset_value(&mut self) -> &mut Payload_DataSet {
        if let ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(Payload_DataSet::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dataset_value(&mut self) -> Payload_DataSet {
        if self.has_dataset_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(v)) => v,
                _ => panic!(),
            }
        } else {
            Payload_DataSet::new()
        }
    }

    // .org.eclipse.tahu.protobuf.Payload.Template template_value = 18;


    pub fn get_template_value(&self) -> &Payload_Template {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(ref v)) => v,
            _ => <Payload_Template as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_template_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_template_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_template_value(&mut self, v: Payload_Template) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_template_value(&mut self) -> &mut Payload_Template {
        if let ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(Payload_Template::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_template_value(&mut self) -> Payload_Template {
        if self.has_template_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(v)) => v,
                _ => panic!(),
            }
        } else {
            Payload_Template::new()
        }
    }
}

impl ::protobuf::Message for Payload_Metric {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Payload_Metric_oneof_value::dataset_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Payload_Metric_oneof_value::template_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.alias = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.datatype = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_historical = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_transient = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_null = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.properties)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::int_value(is.read_uint32()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::long_value(is.read_uint64()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::float_value(is.read_float()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::double_value(is.read_double()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::boolean_value(is.read_bool()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(is.read_string()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(is.read_bytes()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.alias != 0 {
            my_size += ::protobuf::rt::value_size(2, self.alias, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.datatype != 0 {
            my_size += ::protobuf::rt::value_size(4, self.datatype, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_historical != false {
            my_size += 2;
        }
        if self.is_transient != false {
            my_size += 2;
        }
        if self.is_null != false {
            my_size += 2;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.properties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_Metric_oneof_value::int_value(v) => {
                    my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_Metric_oneof_value::long_value(v) => {
                    my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_Metric_oneof_value::float_value(v) => {
                    my_size += 5;
                },
                &Payload_Metric_oneof_value::double_value(v) => {
                    my_size += 9;
                },
                &Payload_Metric_oneof_value::boolean_value(v) => {
                    my_size += 2;
                },
                &Payload_Metric_oneof_value::string_value(ref v) => {
                    my_size += ::protobuf::rt::string_size(15, &v);
                },
                &Payload_Metric_oneof_value::bytes_value(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(16, &v);
                },
                &Payload_Metric_oneof_value::dataset_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Payload_Metric_oneof_value::template_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.alias != 0 {
            os.write_uint64(2, self.alias)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(3, self.timestamp)?;
        }
        if self.datatype != 0 {
            os.write_uint32(4, self.datatype)?;
        }
        if self.is_historical != false {
            os.write_bool(5, self.is_historical)?;
        }
        if self.is_transient != false {
            os.write_bool(6, self.is_transient)?;
        }
        if self.is_null != false {
            os.write_bool(7, self.is_null)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.properties.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_Metric_oneof_value::int_value(v) => {
                    os.write_uint32(10, v)?;
                },
                &Payload_Metric_oneof_value::long_value(v) => {
                    os.write_uint64(11, v)?;
                },
                &Payload_Metric_oneof_value::float_value(v) => {
                    os.write_float(12, v)?;
                },
                &Payload_Metric_oneof_value::double_value(v) => {
                    os.write_double(13, v)?;
                },
                &Payload_Metric_oneof_value::boolean_value(v) => {
                    os.write_bool(14, v)?;
                },
                &Payload_Metric_oneof_value::string_value(ref v) => {
                    os.write_string(15, v)?;
                },
                &Payload_Metric_oneof_value::bytes_value(ref v) => {
                    os.write_bytes(16, v)?;
                },
                &Payload_Metric_oneof_value::dataset_value(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Payload_Metric_oneof_value::template_value(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_Metric {
        Payload_Metric::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Payload_Metric| { &m.name },
                |m: &mut Payload_Metric| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "alias",
                |m: &Payload_Metric| { &m.alias },
                |m: &mut Payload_Metric| { &mut m.alias },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &Payload_Metric| { &m.timestamp },
                |m: &mut Payload_Metric| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "datatype",
                |m: &Payload_Metric| { &m.datatype },
                |m: &mut Payload_Metric| { &mut m.datatype },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_historical",
                |m: &Payload_Metric| { &m.is_historical },
                |m: &mut Payload_Metric| { &mut m.is_historical },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_transient",
                |m: &Payload_Metric| { &m.is_transient },
                |m: &mut Payload_Metric| { &mut m.is_transient },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_null",
                |m: &Payload_Metric| { &m.is_null },
                |m: &mut Payload_Metric| { &mut m.is_null },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_MetaData>>(
                "metadata",
                |m: &Payload_Metric| { &m.metadata },
                |m: &mut Payload_Metric| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_PropertySet>>(
                "properties",
                |m: &Payload_Metric| { &m.properties },
                |m: &mut Payload_Metric| { &mut m.properties },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "int_value",
                Payload_Metric::has_int_value,
                Payload_Metric::get_int_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "long_value",
                Payload_Metric::has_long_value,
                Payload_Metric::get_long_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor::<_>(
                "float_value",
                Payload_Metric::has_float_value,
                Payload_Metric::get_float_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                "double_value",
                Payload_Metric::has_double_value,
                Payload_Metric::get_double_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "boolean_value",
                Payload_Metric::has_boolean_value,
                Payload_Metric::get_boolean_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "string_value",
                Payload_Metric::has_string_value,
                Payload_Metric::get_string_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "bytes_value",
                Payload_Metric::has_bytes_value,
                Payload_Metric::get_bytes_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Payload_DataSet>(
                "dataset_value",
                Payload_Metric::has_dataset_value,
                Payload_Metric::get_dataset_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Payload_Template>(
                "template_value",
                Payload_Metric::has_template_value,
                Payload_Metric::get_template_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_Metric>(
                "Payload.Metric",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_Metric {
        static instance: ::protobuf::rt::LazyV2<Payload_Metric> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_Metric::new)
    }
}

impl ::protobuf::Clear for Payload_Metric {
    fn clear(&mut self) {
        self.name.clear();
        self.alias = 0;
        self.timestamp = 0;
        self.datatype = 0;
        self.is_historical = false;
        self.is_transient = false;
        self.is_null = false;
        self.metadata.clear();
        self.properties.clear();
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_Metric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_Metric {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DataType {
    Unknown = 0,
    Int8 = 1,
    Int16 = 2,
    Int32 = 3,
    Int64 = 4,
    UInt8 = 5,
    UInt16 = 6,
    UInt32 = 7,
    UInt64 = 8,
    Float = 9,
    Double = 10,
    Boolean = 11,
    String = 12,
    DateTime = 13,
    Text = 14,
    UUID = 15,
    DataSet = 16,
    Bytes = 17,
    File = 18,
    Template = 19,
    PropertySet = 20,
    PropertySetList = 21,
    Int8Array = 22,
    Int16Array = 23,
    Int32Array = 24,
    Int64Array = 25,
    UInt8Array = 26,
    UInt16Array = 27,
    UInt32Array = 28,
    UInt64Array = 29,
    FloatArray = 30,
    DoubleArray = 31,
    BooleanArray = 32,
    StringArray = 33,
    DateTimeArray = 34,
}

impl ::protobuf::ProtobufEnum for DataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataType> {
        match value {
            0 => ::std::option::Option::Some(DataType::Unknown),
            1 => ::std::option::Option::Some(DataType::Int8),
            2 => ::std::option::Option::Some(DataType::Int16),
            3 => ::std::option::Option::Some(DataType::Int32),
            4 => ::std::option::Option::Some(DataType::Int64),
            5 => ::std::option::Option::Some(DataType::UInt8),
            6 => ::std::option::Option::Some(DataType::UInt16),
            7 => ::std::option::Option::Some(DataType::UInt32),
            8 => ::std::option::Option::Some(DataType::UInt64),
            9 => ::std::option::Option::Some(DataType::Float),
            10 => ::std::option::Option::Some(DataType::Double),
            11 => ::std::option::Option::Some(DataType::Boolean),
            12 => ::std::option::Option::Some(DataType::String),
            13 => ::std::option::Option::Some(DataType::DateTime),
            14 => ::std::option::Option::Some(DataType::Text),
            15 => ::std::option::Option::Some(DataType::UUID),
            16 => ::std::option::Option::Some(DataType::DataSet),
            17 => ::std::option::Option::Some(DataType::Bytes),
            18 => ::std::option::Option::Some(DataType::File),
            19 => ::std::option::Option::Some(DataType::Template),
            20 => ::std::option::Option::Some(DataType::PropertySet),
            21 => ::std::option::Option::Some(DataType::PropertySetList),
            22 => ::std::option::Option::Some(DataType::Int8Array),
            23 => ::std::option::Option::Some(DataType::Int16Array),
            24 => ::std::option::Option::Some(DataType::Int32Array),
            25 => ::std::option::Option::Some(DataType::Int64Array),
            26 => ::std::option::Option::Some(DataType::UInt8Array),
            27 => ::std::option::Option::Some(DataType::UInt16Array),
            28 => ::std::option::Option::Some(DataType::UInt32Array),
            29 => ::std::option::Option::Some(DataType::UInt64Array),
            30 => ::std::option::Option::Some(DataType::FloatArray),
            31 => ::std::option::Option::Some(DataType::DoubleArray),
            32 => ::std::option::Option::Some(DataType::BooleanArray),
            33 => ::std::option::Option::Some(DataType::StringArray),
            34 => ::std::option::Option::Some(DataType::DateTimeArray),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataType] = &[
            DataType::Unknown,
            DataType::Int8,
            DataType::Int16,
            DataType::Int32,
            DataType::Int64,
            DataType::UInt8,
            DataType::UInt16,
            DataType::UInt32,
            DataType::UInt64,
            DataType::Float,
            DataType::Double,
            DataType::Boolean,
            DataType::String,
            DataType::DateTime,
            DataType::Text,
            DataType::UUID,
            DataType::DataSet,
            DataType::Bytes,
            DataType::File,
            DataType::Template,
            DataType::PropertySet,
            DataType::PropertySetList,
            DataType::Int8Array,
            DataType::Int16Array,
            DataType::Int32Array,
            DataType::Int64Array,
            DataType::UInt8Array,
            DataType::UInt16Array,
            DataType::UInt32Array,
            DataType::UInt64Array,
            DataType::FloatArray,
            DataType::DoubleArray,
            DataType::BooleanArray,
            DataType::StringArray,
            DataType::DateTimeArray,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataType>("DataType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataType {
}

impl ::std::default::Default for DataType {
    fn default() -> Self {
        DataType::Unknown
    }
}

impl ::protobuf::reflect::ProtobufValue for DataType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tspb.proto\x12\x19org.eclipse.tahu.protobuf\"\xfe\x17\n\x07Payload\
    \x12\x1e\n\ttimestamp\x18\x01\x20\x01(\x04R\ttimestampB\0\x12E\n\x07metr\
    ics\x18\x02\x20\x03(\x0b2).org.eclipse.tahu.protobuf.Payload.MetricR\x07\
    metricsB\0\x12\x12\n\x03seq\x18\x03\x20\x01(\x04R\x03seqB\0\x12\x14\n\
    \x04uuid\x18\x04\x20\x01(\tR\x04uuidB\0\x12\x14\n\x04body\x18\x05\x20\
    \x01(\x0cR\x04bodyB\0\x1a\xb9\x04\n\x08Template\x12\x1a\n\x07version\x18\
    \x01\x20\x01(\tR\x07versionB\0\x12E\n\x07metrics\x18\x02\x20\x03(\x0b2).\
    org.eclipse.tahu.protobuf.Payload.MetricR\x07metricsB\0\x12W\n\nparamete\
    rs\x18\x03\x20\x03(\x0b25.org.eclipse.tahu.protobuf.Payload.Template.Par\
    ameterR\nparametersB\0\x12#\n\x0ctemplate_ref\x18\x04\x20\x01(\tR\x0btem\
    plateRefB\0\x12%\n\ris_definition\x18\x05\x20\x01(\x08R\x0cisDefinitionB\
    \0\x1a\xa2\x02\n\tParameter\x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nam\
    eB\0\x12\x14\n\x04type\x18\x02\x20\x01(\rR\x04typeB\0\x12\x1f\n\tint_val\
    ue\x18\x03\x20\x01(\rH\0R\x08intValueB\0\x12!\n\nlong_value\x18\x04\x20\
    \x01(\x04H\0R\tlongValueB\0\x12#\n\x0bfloat_value\x18\x05\x20\x01(\x02H\
    \0R\nfloatValueB\0\x12%\n\x0cdouble_value\x18\x06\x20\x01(\x01H\0R\x0bdo\
    ubleValueB\0\x12'\n\rboolean_value\x18\x07\x20\x01(\x08H\0R\x0cbooleanVa\
    lueB\0\x12%\n\x0cstring_value\x18\x08\x20\x01(\tH\0R\x0bstringValueB\0B\
    \x07\n\x05value:\0:\0\x1a\x89\x04\n\x07DataSet\x12&\n\x0enum_of_columns\
    \x18\x01\x20\x01(\x04R\x0cnumOfColumnsB\0\x12\x1a\n\x07columns\x18\x02\
    \x20\x03(\tR\x07columnsB\0\x12\x16\n\x05types\x18\x03\x20\x03(\rR\x05typ\
    esB\0\x12D\n\x04rows\x18\x04\x20\x03(\x0b2..org.eclipse.tahu.protobuf.Pa\
    yload.DataSet.RowR\x04rowsB\0\x1a\xf9\x01\n\x0cDataSetValue\x12\x1f\n\ti\
    nt_value\x18\x01\x20\x01(\rH\0R\x08intValueB\0\x12!\n\nlong_value\x18\
    \x02\x20\x01(\x04H\0R\tlongValueB\0\x12#\n\x0bfloat_value\x18\x03\x20\
    \x01(\x02H\0R\nfloatValueB\0\x12%\n\x0cdouble_value\x18\x04\x20\x01(\x01\
    H\0R\x0bdoubleValueB\0\x12'\n\rboolean_value\x18\x05\x20\x01(\x08H\0R\
    \x0cbooleanValueB\0\x12%\n\x0cstring_value\x18\x06\x20\x01(\tH\0R\x0bstr\
    ingValueB\0B\x07\n\x05value:\0\x1a^\n\x03Row\x12U\n\x08elements\x18\x01\
    \x20\x03(\x0b27.org.eclipse.tahu.protobuf.Payload.DataSet.DataSetValueR\
    \x08elementsB\0:\0:\0\x1a\xf3\x03\n\rPropertyValue\x12\x14\n\x04type\x18\
    \x01\x20\x01(\rR\x04typeB\0\x12\x19\n\x07is_null\x18\x02\x20\x01(\x08R\
    \x06isNullB\0\x12\x1f\n\tint_value\x18\x03\x20\x01(\rH\0R\x08intValueB\0\
    \x12!\n\nlong_value\x18\x04\x20\x01(\x04H\0R\tlongValueB\0\x12#\n\x0bflo\
    at_value\x18\x05\x20\x01(\x02H\0R\nfloatValueB\0\x12%\n\x0cdouble_value\
    \x18\x06\x20\x01(\x01H\0R\x0bdoubleValueB\0\x12'\n\rboolean_value\x18\
    \x07\x20\x01(\x08H\0R\x0cbooleanValueB\0\x12%\n\x0cstring_value\x18\x08\
    \x20\x01(\tH\0R\x0bstringValueB\0\x12_\n\x11propertyset_value\x18\t\x20\
    \x01(\x0b2..org.eclipse.tahu.protobuf.Payload.PropertySetH\0R\x10propert\
    ysetValueB\0\x12e\n\x12propertysets_value\x18\n\x20\x01(\x0b22.org.eclip\
    se.tahu.protobuf.Payload.PropertySetListH\0R\x11propertysetsValueB\0B\
    \x07\n\x05value:\0\x1aq\n\x0bPropertySet\x12\x14\n\x04keys\x18\x01\x20\
    \x03(\tR\x04keysB\0\x12J\n\x06values\x18\x02\x20\x03(\x0b20.org.eclipse.\
    tahu.protobuf.Payload.PropertyValueR\x06valuesB\0:\0\x1ag\n\x0fPropertyS\
    etList\x12R\n\x0bpropertyset\x18\x01\x20\x03(\x0b2..org.eclipse.tahu.pro\
    tobuf.Payload.PropertySetR\x0bpropertysetB\0:\0\x1a\xf7\x01\n\x08MetaDat\
    a\x12$\n\ris_multi_part\x18\x01\x20\x01(\x08R\x0bisMultiPartB\0\x12#\n\
    \x0ccontent_type\x18\x02\x20\x01(\tR\x0bcontentTypeB\0\x12\x14\n\x04size\
    \x18\x03\x20\x01(\x04R\x04sizeB\0\x12\x12\n\x03seq\x18\x04\x20\x01(\x04R\
    \x03seqB\0\x12\x1d\n\tfile_name\x18\x05\x20\x01(\tR\x08fileNameB\0\x12\
    \x1d\n\tfile_type\x18\x06\x20\x01(\tR\x08fileTypeB\0\x12\x12\n\x03md5\
    \x18\x07\x20\x01(\tR\x03md5B\0\x12\"\n\x0bdescription\x18\x08\x20\x01(\t\
    R\x0bdescriptionB\0:\0\x1a\xb5\x06\n\x06Metric\x12\x14\n\x04name\x18\x01\
    \x20\x01(\tR\x04nameB\0\x12\x16\n\x05alias\x18\x02\x20\x01(\x04R\x05alia\
    sB\0\x12\x1e\n\ttimestamp\x18\x03\x20\x01(\x04R\ttimestampB\0\x12\x1c\n\
    \x08datatype\x18\x04\x20\x01(\rR\x08datatypeB\0\x12%\n\ris_historical\
    \x18\x05\x20\x01(\x08R\x0cisHistoricalB\0\x12#\n\x0cis_transient\x18\x06\
    \x20\x01(\x08R\x0bisTransientB\0\x12\x19\n\x07is_null\x18\x07\x20\x01(\
    \x08R\x06isNullB\0\x12I\n\x08metadata\x18\x08\x20\x01(\x0b2+.org.eclipse\
    .tahu.protobuf.Payload.MetaDataR\x08metadataB\0\x12P\n\nproperties\x18\t\
    \x20\x01(\x0b2..org.eclipse.tahu.protobuf.Payload.PropertySetR\nproperti\
    esB\0\x12\x1f\n\tint_value\x18\n\x20\x01(\rH\0R\x08intValueB\0\x12!\n\nl\
    ong_value\x18\x0b\x20\x01(\x04H\0R\tlongValueB\0\x12#\n\x0bfloat_value\
    \x18\x0c\x20\x01(\x02H\0R\nfloatValueB\0\x12%\n\x0cdouble_value\x18\r\
    \x20\x01(\x01H\0R\x0bdoubleValueB\0\x12'\n\rboolean_value\x18\x0e\x20\
    \x01(\x08H\0R\x0cbooleanValueB\0\x12%\n\x0cstring_value\x18\x0f\x20\x01(\
    \tH\0R\x0bstringValueB\0\x12#\n\x0bbytes_value\x18\x10\x20\x01(\x0cH\0R\
    \nbytesValueB\0\x12S\n\rdataset_value\x18\x11\x20\x01(\x0b2*.org.eclipse\
    .tahu.protobuf.Payload.DataSetH\0R\x0cdatasetValueB\0\x12V\n\x0etemplate\
    _value\x18\x12\x20\x01(\x0b2+.org.eclipse.tahu.protobuf.Payload.Template\
    H\0R\rtemplateValueB\0B\x07\n\x05value:\0:\0*\xf4\x03\n\x08DataType\x12\
    \x0b\n\x07Unknown\x10\0\x12\x08\n\x04Int8\x10\x01\x12\t\n\x05Int16\x10\
    \x02\x12\t\n\x05Int32\x10\x03\x12\t\n\x05Int64\x10\x04\x12\t\n\x05UInt8\
    \x10\x05\x12\n\n\x06UInt16\x10\x06\x12\n\n\x06UInt32\x10\x07\x12\n\n\x06\
    UInt64\x10\x08\x12\t\n\x05Float\x10\t\x12\n\n\x06Double\x10\n\x12\x0b\n\
    \x07Boolean\x10\x0b\x12\n\n\x06String\x10\x0c\x12\x0c\n\x08DateTime\x10\
    \r\x12\x08\n\x04Text\x10\x0e\x12\x08\n\x04UUID\x10\x0f\x12\x0b\n\x07Data\
    Set\x10\x10\x12\t\n\x05Bytes\x10\x11\x12\x08\n\x04File\x10\x12\x12\x0c\n\
    \x08Template\x10\x13\x12\x0f\n\x0bPropertySet\x10\x14\x12\x13\n\x0fPrope\
    rtySetList\x10\x15\x12\r\n\tInt8Array\x10\x16\x12\x0e\n\nInt16Array\x10\
    \x17\x12\x0e\n\nInt32Array\x10\x18\x12\x0e\n\nInt64Array\x10\x19\x12\x0e\
    \n\nUInt8Array\x10\x1a\x12\x0f\n\x0bUInt16Array\x10\x1b\x12\x0f\n\x0bUIn\
    t32Array\x10\x1c\x12\x0f\n\x0bUInt64Array\x10\x1d\x12\x0e\n\nFloatArray\
    \x10\x1e\x12\x0f\n\x0bDoubleArray\x10\x1f\x12\x10\n\x0cBooleanArray\x10\
    \x20\x12\x0f\n\x0bStringArray\x10!\x12\x11\n\rDateTimeArray\x10\"\x1a\0B\
    \0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
